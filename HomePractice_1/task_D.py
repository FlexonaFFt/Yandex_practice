def remove_barier(row, col, matrix, directions):
    for dr, dc in directions:
        r, c = row + dr, col + dc
        while (0 <= r < 8 and 0 <= c < 8 and matrix[r][c] != 'R' 
               and matrix[r][c] != "B"):
            if matrix[r][c] == "*":
                matrix[r][c] = 0
            r += dr
            c += dc 
    return matrix

matrix = [list(input().strip()) for _ in range(8)]
directions_rook = [(1, 0), (-1, 0), (0, 1), (0, -1)]
directions_bishop = [(1, 1), (-1, -1), (1, -1), (-1, 1)]

for row in range(8):
    for col in range(8):
        if matrix[row][col] == 'R':
            matrix = remove_barier(row, col, matrix, directions_rook)
        elif matrix[row][col] == 'B':
            matrix = remove_barier(row, col, matrix, directions_bishop)

print(sum(row.count('*') for row in matrix))

'''
remove_barier, которая обрабатывает движение ладьи и слона по доске, 
учитывая их возможные направления. Затем основной код пробегает 
по каждой клетке доски, вызывая remove_barier при обнаружении ладьи или слона, 
и подсчитывает количество пустых клеток, которые не бьются ни одной из фигур.

Функция принимает следующие аргументы:
row: текущая строка на доске
col: текущий столбец на доске
matrix: матрица, представляющая шахматную доску
directions: список направлений, в которых может двигаться фигура (для ладьи и слона)

Далее функция начинает итерацию по каждому направлению из списка directions.
Для каждого направления она вычисляет новые координаты (r, c) на доске.
Затем, пока новые координаты (r, c) находятся в пределах доски (от 0 до 7) 
и клетка не содержит фигуру ладьи или слона ('R' или 'B'), функция 
продолжает двигаться по этому направлению. Если текущая клетка пуста ('*'), 
то она помечается как небитая фигурой (значение 0). По завершении обработки 
всех направлений функция возвращает обновленную матрицу matrix, 
где пустые клетки, набитые фигурами, помечены значением 0.
'''